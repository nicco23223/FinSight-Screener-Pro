# -*- coding: utf-8 -*-
"""interactiveMACD_stock_chart.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1srL5RrRtx2J6FXv42nWSq80Kgdvjc1-p
"""

# %pip install plotly pandas requests python-dateutil

import os, time, requests, numpy as np, pandas as pd
from datetime import datetime, timezone
from dateutil.relativedelta import relativedelta
import plotly.graph_objects as go
from plotly.subplots import make_subplots
import streamlit as st 

# ================= 基本設定 =================
BASE = "https://api.polygon.io"
API_KEY = "J_wZYB3rGZBaFv2tdyg21X1vmVXrMW21"

DEFAULT_START = (datetime.now(timezone.utc) - relativedelta(years=3)).date().isoformat()
DEFAULT_END   = datetime.now(timezone.utc).date().isoformat()


# ================= HTTP Helper =================
def _get(url: str, params: dict | None = None, max_retry: int = 5) -> requests.Response:
    params = dict(params or {})
    if "apiKey" not in params:
        params["apiKey"] = API_KEY
    r = None
    for attempt in range(max_retry):
        r = requests.get(url, params=params, timeout=30)
        if r.status_code == 429:
            time.sleep(int(r.headers.get("Retry-After", "2"))); continue
        if 500 <= r.status_code < 600:
            time.sleep(1.5 * (attempt + 1)); continue
        break
    return r


# ================= Snapshot volume =================
def fetch_snapshot_volume(ticker: str) -> float | None:
    """抓當日即時累積成交量（/v2/snapshot/.../tickers/{ticker}）"""
    url = f"{BASE}/v2/snapshot/locale/us/markets/stocks/tickers/{ticker.upper()}"
    r = _get(url)
    if not r.ok:
        print(f"[WARN] snapshot error {r.status_code}")
        return None
    js = r.json()
    return js.get("ticker", {}).get("day", {}).get("v")


# ================= 抓歷史價量 =================
def fetch_aggs(ticker: str, mult="1", timespan="day",
               start=None, end=None, adjusted=True) -> pd.DataFrame:
    if not start:
        start = DEFAULT_START
    if not end:
        end = DEFAULT_END
    url = f"{BASE}/v2/aggs/ticker/{ticker}/range/{mult}/{timespan}/{start}/{end}"
    r = _get(url, {"adjusted": str(adjusted).lower(), "sort":"asc", "limit":50000})
    if not r.ok:
        raise RuntimeError(f"Polygon error {r.status_code}: {r.text[:200]}")
    data = r.json().get("results", [])
    df = pd.DataFrame(data)
    if df.empty: return df
    df = df.rename(columns={"t":"timestamp","o":"open","h":"high","l":"low","c":"close","v":"volume"})
    df["datetime"] = pd.to_datetime(df["timestamp"], unit="ms", utc=True).dt.tz_convert("US/Eastern")
    return df.set_index("datetime")[["open","high","low","close","volume"]]


# ================= 技術指標 =================
def ema(series: pd.Series, span: int) -> pd.Series:
    return series.ewm(span=span, adjust=False).mean()

def macd(series: pd.Series, fast=12, slow=26, signal=9):
    ema_fast = ema(series, fast)
    ema_slow = ema(series, slow)
    macd_line = ema_fast - ema_slow
    signal_line = ema(macd_line, signal)
    hist = macd_line - signal_line
    return macd_line, signal_line, hist

def _infer_bar_width_ms(index: pd.DatetimeIndex) -> int:
    if len(index) < 2: return 24*60*60*1000
    med = (index[1:] - index[:-1]).to_series().dt.total_seconds().median()
    return int(med * 1000 * 0.8)


# ---- 計算某個 X 區間的三個 Y 軸範圍（含 padding） ----
def _ranges_for_window(df: pd.DataFrame, x0: pd.Timestamp, x1: pd.Timestamp):
    vis = df.loc[x0:x1]
    if vis.empty:
        vis = df
    p_min, p_max = float(vis["low"].min()), float(vis["high"].max())
    pad_p = (p_max - p_min) * 0.08 if p_max > p_min else (p_max or 1) * 0.08
    y1 = [p_min - pad_p, p_max + pad_p]
    v_max = float((vis["volume"].max() or 0))
    y2 = [0, v_max * 1.1 if v_max > 0 else 1]
    m_min = float(np.nanmin([vis["MACD"].min(), vis["SIGNAL"].min(), vis["HIST"].min()]))
    m_max = float(np.nanmax([vis["MACD"].max(), vis["SIGNAL"].max(), vis["HIST"].max()]))
    pad_m = (m_max - m_min) * 0.15 if m_max > m_min else 1
    y3 = [m_min - pad_m, m_max + pad_m]
    return y1, y2, y3


# ================= 繪圖 =================
def plot_price_macd_vol(df: pd.DataFrame, ticker: str,
                        add_level: float | None = None,
                        initial_window_days: int = 180):
    if df.empty or "close" not in df.columns:
        raise ValueError("沒有資料可畫圖")

    df = df.copy()
    df["EMA200"] = ema(df["close"], 200)
    df["MACD"], df["SIGNAL"], df["HIST"] = macd(df["close"])

    snap_vol = fetch_snapshot_volume(ticker)
    if snap_vol is not None:
        df.iloc[-1, df.columns.get_loc("volume")] = snap_vol
        print(f"即時成交量更新：{snap_vol:,.0f}")

    inc_color, dec_color = "rgba(0,180,0,1)", "rgba(220,0,0,1)"
    marker_color = np.where(df["close"] >= df["open"], "rgba(0,180,0,0.85)", "rgba(220,0,0,0.85)")
    hist_colors  = np.where(df["HIST"] >= 0, "rgba(0,180,0,0.9)", "rgba(220,0,0,0.9)")
    bar_w = _infer_bar_width_ms(df.index)

    fig = make_subplots(
        rows=3, cols=1, shared_xaxes=True, vertical_spacing=0.02,
        row_heights=[0.55, 0.20, 0.25]
    )

    # (1) Price + EMA200
    fig.add_trace(go.Candlestick(
        x=df.index, open=df["open"], high=df["high"], low=df["low"], close=df["close"],
        increasing_line_color=inc_color, decreasing_line_color=dec_color,
        name="Price"), row=1, col=1)
    fig.add_trace(go.Scatter(
        x=df.index, y=df["EMA200"], mode="lines", name="EMA200",
        line=dict(width=1.5, color="orange")), row=1, col=1)
    if isinstance(add_level, (int, float)):
        fig.add_hline(y=add_level, line_dash="dash", line_width=1, row=1, col=1)

    # (2) Volume（Bar）
    fig.add_trace(go.Bar(
        x=df.index, y=df["volume"].fillna(0), base=0, width=bar_w,
        marker=dict(color=marker_color), name="Volume", opacity=0.8), row=2, col=1)
    fig.update_yaxes(rangemode="tozero", row=2, col=1)

    # (3) MACD
    fig.add_trace(go.Bar(
        x=df.index, y=df["HIST"], width=bar_w, marker=dict(color=hist_colors),
        name="MACD Hist", opacity=0.85), row=3, col=1)
    fig.add_trace(go.Scatter(
        x=df.index, y=df["MACD"], name="MACD", mode="lines",
        line=dict(width=1.6, color="gold")), row=3, col=1)
    fig.add_trace(go.Scatter(
        x=df.index, y=df["SIGNAL"], name="Signal", mode="lines",
        line=dict(width=1.3, dash="dot", color="deepskyblue")), row=3, col=1)
    fig.add_hline(y=0, line_dash="dash", line_width=1, row=3, col=1)

    # Layout：rangeslider 只在最底下
    fig.update_layout(
        template="plotly_dark",
        title=f"{ticker} • Price / Volume / MACD",
        legend_orientation="h", legend_y=1.02, legend_x=0.01,
        margin=dict(l=40, r=20, t=60, b=80),
        hovermode="x unified",
        xaxis_rangeslider_visible=False
    )
    fig.update_xaxes(rangeslider_visible=False, row=1, col=1)
    fig.update_xaxes(rangeslider_visible=False, row=2, col=1)
    fig.update_xaxes(rangeslider_visible=True,  row=3, col=1)
    fig.update_layout(
        xaxis3_rangeslider_thickness=0.08,
        xaxis3_rangeslider_bgcolor="rgba(30,30,30,0.7)"
    )

    # 移除假日 / 週末空白
    rangebreaks = [dict(bounds=["sat", "mon"])]
    for r in (1, 2, 3):
        fig.update_xaxes(rangebreaks=rangebreaks, row=r, col=1)

    fig.update_yaxes(title_text="Price",  row=1, col=1)
    fig.update_yaxes(title_text="Volume", row=2, col=1)
    fig.update_yaxes(title_text="MACD",   row=3, col=1)

    # -------- 快捷縮放按鈕 --------
    x_end = df.index.max()
    presets = {"3M": 90, "6M": 180, "1Y": 365, "2Y": 730, "All": None}
    buttons = []
    for name, days in presets.items():
        if days is None:
            x0 = df.index.min(); x1 = df.index.max()
        else:
            x1 = x_end; x0 = x1 - pd.Timedelta(days=days)
            if x0 < df.index.min(): x0 = df.index.min()
        y1, y2, y3 = _ranges_for_window(df, x0, x1)
        args = {"xaxis3.range": [x0, x1],
                "yaxis.range": y1, "yaxis2.range": y2, "yaxis3.range": y3}
        buttons.append(dict(label=name, method="relayout", args=[args]))

    fig.update_layout(
        updatemenus=[dict(
            type="buttons", direction="left",
            x=0.5, y=-0.20, xanchor="center", yanchor="top",  # ✅ 放到底部中央
            showactive=True, bgcolor="rgba(40,40,40,0.6)",
            bordercolor="gray", borderwidth=1, pad={"r": 10, "t": 10},
            buttons=buttons
        )]
    )

    # 初始視窗：6M
    x1 = x_end; x0 = x1 - pd.Timedelta(days=180)
    if x0 < df.index.min(): x0 = df.index.min()
    y1, y2, y3 = _ranges_for_window(df, x0, x1)
    fig.update_layout(xaxis3_range=[x0, x1],
                      yaxis_range=y1, yaxis2_range=y2, yaxis3_range=y3)

    st.plotly_chart(fig, use_container_width=True)




# ================= Streamlit interactive entry =================
# ================= 執行入口 =================
def run_chart(ticker="FDP", add_level=None, start=DEFAULT_START, end=DEFAULT_END):
    df = fetch_aggs(ticker, "1", "day", start, end)
    if df.empty:
        print("❌ 無資料，請檢查 Ticker 或日期範圍"); return
    plot_price_macd_vol(df, ticker, add_level=add_level, initial_window_days=180)
    
def render_interactive_macd(tickers: list[str], api_key: str | None = None):
    """
    Streamlit will call this function from 10301.py to render the interactive MACD chart.
    Supports multiple tickers at once.
    """
    import streamlit as st

    if not tickers:
        st.info("No tickers selected.")
        return

    for tk in tickers:
        st.write(f"### {tk}")
        try:
            run_chart(ticker=tk)
        except Exception as e:
            st.warning(f"⚠️ Failed to render chart for {tk}: {e}")

# (Optional example)
# run_chart("META")


